---
title: "seq_alignment: Una función para la significación del alineamiento de secuencias"
author: "Laura Julià Melis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seq_alignment: Una funcion para la significacion del alineamiento de secuencias}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

## 1. Introducción.

El paquete **seqBio** contiene un solo objeto, que es la función `seq_alignment()`. Esta función es útil para estudiar la significación del alineamiento de secuencias y para ello, reliza el cálculo de la probabilidad de que la puntuación del alineamiento ha sido obtenida por azar (aplicando la estrategia de *shuffling*).

## 2. Argumentos de seq_alignment(). 

La función `seq_alignment()` no tiene valores por defecto por lo que para ejecutarla, será **siempre** necesario dar valores a todos sus argumentos de entrada.

  # 2. Comprobación de los inputs:

  - `seq1:` Secuencia 1 en formato Fasta (objeto de tipo carácter).
  - `seq2:` Secuencia 2 en formato Fasta (objeto de tipo carácter).
  - `seq_type:` Tipo de secuencia: "protein" o "dna" (objeto de tipo carácter).
  - `seq_align:` Tipo de alineamiento: "local" o "global" (objeto de tipo carácter).
  - `mat:` Matriz de substitución: PAMn, BLOSUM, … Ver \code{data(package="Biostrings")} para ver todas las opciones disponibles.
  - `gap:` Puntuación Gap: Open penalty, extended penalty (objeto de tipo numérico: vector con dos valores).
  - `N:` Número de replicas (objeto de tipo numérico y entero).
  - `shuff:` Secuencia donde se hace shuffling: 1 o 2 (objeto de tipo numéricoy entero).
  
Cabe mencionar que la función hace una comprobación de las clases y los valores de los inputs, por lo que se obtendrá un `warning` cuando la clase, la longitud o los valores de uno o varios inputs no sean las correctas (las indicadas tanto sobre este párrafo como también en la ayuda de la función).

```{r, eval = FALSE}
#Comprobación de los inputs:
stopifnot(class(seq1) == "character", class(seq2) == "character",
          seq_type %in% c("protein", "dna"), seq_align  %in% c("local", "global"),
          class(gap) == "numeric", class(N) == "numeric", class(shuff) == "numeric",
          length(gap) == 2, length(N) == 1, shuff %in% c(1, 2))
```


## 3. Metodología.

En esta sección se pretende explicar, paso a paso, cómo se realizó la creación de la función y qué cálculos se computan internamente. 

#### 1. Lectura de las secuencias.

En primer lugar, se realiza la lectura de las dos secuencias, *seq1* y *seq2*, a través de la función `readDNAStringSet()` del paquete *Biostrings*.

```{r, eval = FALSE}
s1 = readDNAStringSet(seq1, "fasta")
s2 = readDNAStringSet(seq2, "fasta")
```

#### 2. Alineamiento original (óptimo).

El segundo paso es obtener la puntuacion $S$ del alineamiento original. Esto se lleva a cabo mediante la función `pairwiseAlignment()`. Con el argumento  `scoreOnly = TRUE` se indica que únicamente nos interesa almacenar la puntuación, ya que de no hacerlo, obtendríamos también como resultado las dos secuencias alineadas.

El código utilizado para computar $S$ es el siguiente: 

```{r, eval = FALSE}
S <- pairwiseAlignment(s1, s2, type = seq_align, substitutionMatrix = mat, 
                       gapOpening = gap[1], gapExtension = gap[2], scoreOnly = TRUE)  
```

#### 3. Prodecimiento shuffling.

Una vez obtenida la puntuación original, se debe aplicar la estrategia shuffling a la secuencia que se indica en el argumento de entrada `shuff = c(1,2)`.

Para la realización de este punto, ha sido necesaria la creación de una función auxiliar, `generateSeqsWithMultinomialModel()`.


#####  3.1. generateSeqsWithMultinomialModel()

Los pasos que se siguen en esta función son:

**1.** Cambiar la secuencia de entrada a un vector de letras (esto se lleva a cabo mediante la función `s2c()` del paquete *SeqinR*).

**2.** Calcular las frecuencias de las letras en la secuencia de entrada *inputsequencevector* (de la que se desea generar secuencias aleatorias) mediante la función `table()`.

**3.** Crear un vector de probabilidades (número de veces que aparece la letra en mi secuencia dividido entre la longitud total de la secuencia).

**4.** Hacer X secuencias aleatorias usando la función `sample()` con el argumento *prob* igual a las probabilidades obtenidas en el paso anterior.

**5.** Como resultado final se devuelve el vector de secuencias aleatorias.

*Ejemplo*
```{r, include=FALSE}
library(seqBio)
```

```{r}
generateSeqsWithMultinomialModel("ATTGGCACT",5)
```

Visitar `?generateSeqsWithMultinomialModel` para obtener más información.

#####  3.2. Obtención de las puntuaciones aleatorias.

Dependiendo de la secuencia donde se desee hacer el shuffling, la función `generateSeqsWithMultinomialModel()` se ejecuta sobre *seq1* o sobre *seq2*. Así pues, se obtiene un vector llamado *randomseqs* con las *N* secuencias aleatorias. 

A continuación, se calculan las puntuaciones entre la secuencia intacta y cada una de las secuencias aleatorias. Las puntuaciones se almacenan en un vector *randomscores* de longitud *N*. 

```{r, eval=FALSE}
if(shuff == 1){
  randomseqs <- generateSeqsWithMultinomialModel(as.character(s1[[1]]), N)
  randomscores <- double(N)
  
  for (i in 1:N){
    score <- pairwiseAlignment(randomseqs[i], s2, type = seq_align, substitutionMatrix = mat, 
                               gapOpening = gap[1], gapExtension = gap[2], scoreOnly = TRUE)
    randomscores[i] <- score
  }
    
  } else {
    randomseqs <- generateSeqsWithMultinomialModel(as.character(s2[[1]]), N)
    randomscores <- double(N)
    
    for (i in 1:N){
      score <- pairwiseAlignment(s1, randomseqs[i], type = seq_align, substitutionMatrix = mat, 
                                 gapOpening = gap[1], gapExtension = gap[2], scoreOnly = TRUE)
      randomscores[i] <- score
    }
}
```


#### 4. Cálculos estadísticos.

*Para estos cálculos se consideran les puntuaciones estandarizadas.*

**Media y desviación estándar de las puntiaciones.**

Se calculan la media de las puntuaciones $\bar{x}$ y su desviación estándar $s$.

*Código:*
```{r, eval=FALSE}
x <- mean(randomscores)
s <- sd(randomscores)
```

**Estimación de los parámetros de la distribución Gumbel.**

Se estiman los parámetros de la distribución Gumbel con el método de los momentos. Sus fórmulas son:

$$\hat{\lambda}= \frac{1.2825}{s}$$
$$\hat{u}=\bar{x}-(0.45\cdot s)$$
*Código:*
```{r, eval=FALSE}
lambda <- 1.2825 / s
u <- x - (0.45*s)
```

**Estimación de K**

$K$ es una constante que depende del sistema de puntuación i que verifica la relación:

$$u = \frac{\ln(K \cdot m\cdot n)}{\lambda}$$
donde $m$ i $n$ son las longitudes de las secuencias de alineamiento 1 y 2, respectivamente. 

Su estimación se obtiene con la fórmula:

$$\hat{K}= \frac{\exp(\hat{\lambda}\cdot \hat{u})}{m \cdot n}$$

*Código:*
```{r, eval=FALSE}
m <- width(s1)
n <- width(s2)
K <- exp( (lambda*u) ) / (m*n)
```

**Estandarización de la puntuación S**

La estandarización de las puntuaciones se obtiene con la fórmula:

$$S'= \lambda S - \ln(K \cdot m \cdot n)$$

*Código:*
```{r, eval=FALSE}
S_prima <- (lambda * S) - log( (K*m*n) )
```

**Cálculo de probabilidades.**

* La probabilidad que una puntuación $S$ sea igual o superior a un valor $x$ viene dado por la expresión:

$$P(S \ge x) = 1-\exp(-e^{-\lambda(x-u)})$$

* La probabilidad que una puntuación S' sea igual o superior a un valor x viene dada per la expresión:

$$P(S' \ge x) = 1-\exp(-e^{-x})$$

* La probabilidad de obtener una puntuación tan grande como la puntuación de alineación real:

```{r, eval = FALSE}
prob2 <- sum(randomscores >= S) / N
```

Podemos estimar que la probabilidad de obtener una puntuación tan grande como la puntuación de alineación real por azar es *prob2*, esto seria el p-valor. Si este valor es superior a 0.05 podemos concluir que las secuencias *seq1* y *seq2* no son más similares que dos secuencias aleatorias cualesquiera, por lo que probablemente no sean secuencias relacionadas.

Dicho de otra forma, si el p-valor estimado es superior a 0.05, significaria que hay una probabilidad alta de que podamos obtener una puntuación de alineación tan alta como la puntuacion original $S$ solo por casualidad.

* La probabilidad que un alineamiento de secuencias al azar tenga una puntuación superior a la obtenida por azar e calcula con la expresión:

$$P(S') = 1-\exp(-e^{-S'}) $$
La interpretación de $P(S')$ es que si la probabilidad es baja, entonces la puntuación de las secuencias es poco probable con la hipótesis que son generadas por azar.


*Código:*
```{r, eval=FALSE}
prob <- 1 - exp( exp(-S_prima))
```

## 4. *Output* de seq_alignment().

#### 4.1. Resultado gráfico

#### 4.2. Resultado numérico


## 5. Ejemplos.
This section shows how to use `linreg()` on a well known dataset such as iris.
```{r include=FALSE}
#hello
```

## Referencias.

* Creación de un paquete: <https://support.rstudio.com/hc/en-us/articles/200486488-Developing-Packages-with-RStudio>
* Viñetas: <http://r-pkgs.had.co.nz/vignettes.html>
* Alineamiento de sequencias: <https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/chapter4.html>
* Significación estadística: documento *Significación_estadistica.pdf* de Atenea.